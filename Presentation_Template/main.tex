\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage{tikz}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usetikzlibrary{automata, positioning,arrows.meta,quotes}
\usetheme{Madrid}
\useoutertheme{infolines} 
\useinnertheme{circles}
\usetikzlibrary{arrows}
\usetikzlibrary{decorations.markings}
\usetikzlibrary{decorations.pathmorphing}
\setbeamertemplate{navigation symbols}{}
\newenvironment{myitemize}{\begin{itemize}\setlength\itemsep{3ex}}{\end{itemize}}
\newenvironment{myenumerate}{\begin{enumerate}\setlength\itemsep{3ex}}{\end{enumerate}}
\newcounter{result}[section]
\makeatletter
\setbeamertemplate{footline}
{
  \leavevmode%
  \hbox{%
  \begin{beamercolorbox}[wd=.7\paperwidth,ht=2.25ex,dp=1ex,center]{title in head/foot}%
    \usebeamerfont{title in head/foot}\insertsection
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.3\paperwidth,ht=2.25ex,dp=1ex,right]{date in head/foot}%
    \insertframenumber{} / \inserttotalframenumber\hspace*{2ex}
  \end{beamercolorbox}}%
  \vskip0pt%
}
\makeatother
\date{}%leave blank
\author[]{}%leave blank
\setbeamersize{text margin left=12mm,text margin right=12mm}

 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %Start editing from here
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title[]{Compiler Construction \& Tarjan's Algorithm}
\subtitle{Understanding SCCs in Call Graph Analysis\newline \today}


\definecolor{bottomLeft}{RGB}{255, 200, 87}%color for bottom left footer, and Block top labels (SpongeBob yellow)

\definecolor{headers}{RGB}{0, 150, 200}%color for headers on slides, and table of contents, itemize etc. (Ocean blue)

\definecolor{writing}{RGB}{255,255,255}%color for writing in headers section

\definecolor{mynavy}{RGB}{20, 60, 100}%color for text on slides (Deep ocean blue)

\setbeamercolor{palette primary}{bg=headers,fg=writing}
%bg is for headers, fg is for text
\setbeamercolor{palette secondary}{bg=bottomLeft,fg=writing}
%bg is for left half of footer, fg is for writing
\setbeamercolor{structure}{fg=headers} % itemize, enumerate, etc
\setbeamercolor{section in toc}{fg=headers} % Table of contents sections

%Change text color
\setbeamercolor {normal text} {fg=mynavy} 
\usebeamercolor* {normal text}

\setbeamercolor{block title}{bg=bottomLeft,fg=mynavy}

%below is the logo, you can leave it, remove or replace it
\titlegraphic{\includegraphics[width=5cm,height=1.5cm]{newpaltzlogo.jpg}}

%below are two options for separating sections
\AtBeginSection[]{

   % \begin{frame}[plain]
    %    \sectionpage
    %\end{frame}
     \begin{frame}
    \frametitle{Table of Contents}
    \tableofcontents[currentsection]
  \end{frame}
}
%starts the documents
\begin{document}
{
%this sets an image as a background for the first slide
\setbeamertemplate{background} 
{
    \includegraphics[width=\paperwidth,height=\paperheight]{science-mathematics-abstract-background-circles-cube-triangles-lot-lines-sacred-geometry-backdrop-79621056.jpg}
}
\frame{\titlepage}
}

%Introduction
\section{Introduction}

\begin{frame}{Overview}
This presentation covers:
\begin{myitemize}
    \item Fundamentals of Compiler Construction
    \item Graph Theory in Compilers
    \item Real-World Application: Call Graph Analysis
    \item LLVM Integration
\end{myitemize}
\end{frame}

%Compiler Construction Basics
\section{Compiler Construction Basics}

\begin{frame}{What is a Compiler?}
    \begin{definition}
        A \underline{\textbf{\emph{compiler}}} is a program that translates source code from a high-level programming language into machine code or intermediate representation.
    \end{definition}
    \pause

    \begin{block}{Key Responsibilities}
        \begin{itemize}
            \item Translate human-readable code to executable format
            \item Check for syntax and semantic errors
            \item Optimize code for performance
            \item Generate warnings and error messages
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{Compiler Phases}
The compilation process consists of several phases:
\begin{myenumerate}
    \item \textbf{Lexical Analysis} - Breaking source into tokens
    \item \textbf{Syntax Analysis} - Building parse trees
    \item \textbf{Semantic Analysis} - Type checking, scope resolution
    \item \textbf{Intermediate Code Generation}
    \item \textbf{Optimization}
    \item \textbf{Code Generation}
\end{myenumerate}
\end{frame}

\begin{frame}{Frontend vs Backend}
\begin{columns}
\column{0.5\textwidth}
\begin{block}{Frontend}
    \begin{itemize}
        \item Lexical Analysis
        \item Parsing
        \item Semantic Analysis
        \item Symbol Tables
        \item Type Checking
    \end{itemize}
\end{block}

\column{0.5\textwidth}
\begin{block}{Backend}
    \begin{itemize}
        \item Code Optimization
        \item Register Allocation
        \item Code Generation
        \item Target-specific transforms
    \end{itemize}
\end{block}
\end{columns}
\end{frame}

\subsection{Semantic Analysis}

\begin{frame}{Semantic Analysis Phase}
\begin{myitemize}
    \item \textbf{Type Checking}: Verify type compatibility
    \item \textbf{Scope Resolution}: Variable and function visibility
    \item \textbf{Flow Analysis}: Control and data flow
    \item \textbf{Call Graph Construction}: Function dependencies
\end{myitemize}

\bigskip
\pause

\begin{alertblock}{Why Call Graphs Matter}
Call graphs help detect:
\begin{itemize}
    \item Recursive functions (direct and indirect)
    \item Unreachable code
    \item Optimization opportunities
    \item Stack overflow risks
\end{itemize}
\end{alertblock}
\end{frame}

%Graph Theory in Compilers
\section{Graph Theory in Compilers}

\begin{frame}{Call Graphs}
    \begin{definition}
        A \underline{\textbf{\emph{call graph}}} is a directed graph where nodes represent functions and edges represent function calls.
    \end{definition}
    \pause

    \begin{block}{Example}
        If function \texttt{f()} calls \texttt{g()}, we draw an edge: \texttt{f} $\rightarrow$ \texttt{g}
    \end{block}
    \pause

    \begin{block}{Purpose}
        \begin{itemize}
            \item Analyze program structure
            \item Detect recursion (cycles in the graph)
            \item Optimize function inlining
            \item Determine call order
        \end{itemize}
    \end{block}
\end{frame}


%Implementation in nicoLang
\section{Implementation in nicoLang}

\begin{frame}{nicoLang Compiler}
\begin{block}{Project Overview}
nicoLang is a compiler project that implements call graph analysis using Tarjan's algorithm to detect recursive functions.
\end{block}

\bigskip

\begin{myitemize}
    \item Written in C++
    \item Header-only implementation
    \item Detects both direct and mutual recursion
    \item Provides detailed SCC reporting
\end{myitemize}
\end{frame}

\begin{frame}{Usage in Compilation}
\begin{myenumerate}
    \item During semantic analysis, record function calls
    \item Build the call graph incrementally
    \item After parsing, run \texttt{analyze()}
    \item Tarjan's algorithm detects all SCCs
    \item Compiler can then:
    \begin{itemize}
        \item Warn about recursion
        \item Disable certain optimizations
        \item Verify tail-call optimization applicability
        \item Calculate stack depth requirements
    \end{itemize}
\end{myenumerate}
\end{frame}

\subsection{Benefits}

\begin{frame}{Why This Matters}
\begin{myitemize}
    \item \textbf{Performance}: $O(V + E)$ linear time complexity
    \item \textbf{Correctness}: Detects all forms of recursion
    \item \textbf{Optimization}: Enables better code generation
    \item \textbf{Error Prevention}: Warns about stack overflow
\end{myitemize}

\pause

\begin{block}{Real-World Impact}
\begin{itemize}
    \item Used in GCC, LLVM, and other major compilers
    \item Essential for functional programming languages
    \item Critical for optimization passes
\end{itemize}
\end{block}
\end{frame}

%LLVM and Call Graph Analysis
\section{LLVM and Call Graph Analysis}

\begin{frame}{What is LLVM?}
\begin{block}{LLVM Overview}
LLVM (Low Level Virtual Machine) is a modern compiler infrastructure that provides:
\begin{itemize}
    \item Intermediate Representation (IR) for code optimization
    \item Modular compiler architecture
    \item Language-independent optimization framework
    \item Used by Clang, Swift, Rust, and many others
\end{itemize}
\end{block}

\pause

\begin{myitemize}
    \item \textbf{Frontend}: Language-specific parsing to LLVM IR
    \item \textbf{Middle-end}: Optimization passes on IR
    \item \textbf{Backend}: IR to machine code generation
\end{myitemize}
\end{frame}

\begin{frame}{LLVM Optimization Passes}
\begin{block}{Call Graph-Based Optimizations}
LLVM uses call graph analysis for multiple optimization passes:
\end{block}

\begin{myitemize}
    \item \textbf{Function Inlining}: Inline small, frequently-called functions
    \item \textbf{Dead Argument Elimination}: Remove unused function parameters
    \item \textbf{Interprocedural Constant Propagation}: Propagate constants across function boundaries
    \item \textbf{Tail Call Optimization}: Convert recursive calls to iterations
\end{myitemize}

\pause

\begin{alertblock}{Bottom-Up Processing}
SCCs enable bottom-up analysis: analyze callees before callers, maximizing optimization opportunities.
\end{alertblock}
\end{frame}

\begin{frame}{Using LLVM in nicoLang}
\begin{block}{Integration Approach}
We leverage LLVM's optimization infrastructure for call graph analysis and optimization passes.
\end{block}

\bigskip

\begin{myitemize}
    \item Generate LLVM IR from nicoLang source code
    \item Use optimization passes for code improvement
    \item Detect recursive functions through SCC analysis
    \item Generate optimized machine code
\end{myitemize}

\pause

\begin{alertblock}{Benefits}
LLVM provides production-ready infrastructure for sophisticated compiler optimizations and analysis.
\end{alertblock}
\end{frame}

%Conclusion
\section{Conclusion}

\begin{frame}{Summary}
\begin{myitemize}
    \item Compilers transform source code through multiple phases
    \item Call graphs represent function dependencies
    \item SCCs identify recursive function groups
    \item Tarjan's algorithm efficiently finds all SCCs
    \item nicoLang implements this for recursion detection
\end{myitemize}

\bigskip

\begin{block}{Key Takeaway}
Graph algorithms like Tarjan's SCC are fundamental to modern compiler construction, enabling sophisticated analysis and optimization.
\end{block}
\end{frame}

\begin{frame}{References}
    \begin{thebibliography}{}
%Original Paper
\bibitem{Tarjan72}
Robert Tarjan: Depth-First Search and Linear Graph Algorithms.
SIAM Journal on Computing, 1(2):146-160, 1972.

%LLVM
\bibitem{LLVM}
LLVM Project: The LLVM Compiler Infrastructure.
\url{https://llvm.org/}
\end{thebibliography}
\end{frame}



{
\setbeamertemplate{background} 
{
    \includegraphics[width=\paperwidth,height=\paperheight]{science-mathematics-abstract-background-circles-cube-triangles-lot-lines-sacred-geometry-backdrop-79621056.jpg}
}

\begin{frame}{}
    \begin{huge}
        \begin{center}
        \textbf{ {Thank You! \\ Questions?}}\\
           
        \end{center}
    \end{huge}
\end{frame}
}


\end{document}